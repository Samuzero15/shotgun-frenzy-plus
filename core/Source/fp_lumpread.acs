
///////////////////////////////////////////////////
//      SHOTGUN FRENZY PLUS
//   a Shotgun Frenzy fork by Samuzero15tlh

// fl_lumpread.acs
// The library for lump-reading, 
// a new thing for Zandronum 3.2 that ease us the addon creation for mods, like this one!
// TDRR, you absolute madlad.

#library "fp_lumpread"
#include "zcommon.acs"
#include "acsutils.acs"
#import "fl_WDir.acs"

#libdefine LUMPR_VALUE_NULL     0
#libdefine LUMPR_VALUE_INT      1
#libdefine LUMPR_VALUE_FIXED    2
#libdefine LUMPR_VALUE_STR      3
#libdefine LUMPR_VALUE_BOOL     4
#libdefine LUMPR_VALUE_LANGSTR  5
#libdefine LUMPR_VALUE_CVAR     6
#libdefine LUMPR_VALUE_USERCVAR 7

function bool LumpRead_ParseBool (str string){
    bool res = false;
    if(StrIEquals(string, "true") || StrIEquals(string, "1")) res = true;
    else if (StrIEquals(string, "false") || StrIEquals(string, "0")) res = false;
    return res;
}

function int LumpRead_ParseValue (str string_value, int value_type){
    int value = -1;
    switch(value_type){
        case LUMPR_VALUE_INT: value = atoi(string_value); break;
        case LUMPR_VALUE_FIXED: value = atof(string_value); break;
        case LUMPR_VALUE_STR: value = StrReplace(string_value, "\\n", strparam(c:'\n')); break;
        case LUMPR_VALUE_BOOL: value = LumpRead_ParseBool(string_value); break;
        case LUMPR_VALUE_LANGSTR: value = StrReplace(strparam(l:string_value), "\\n", strparam(c:'\n')); break;
        case LUMPR_VALUE_CVAR: value = GetCvar(string_value);
        default:
            //log(s:"command: ", d:tokenid);
    }
    return value;
}

int res1, res2;
int lumpread_busy = 0; // 
int lumpread_busyfile = 0; // 

global bool 30:lumpread_initialized;
global int 32:lumpread_count;
global int 31:lumpread_files[]; // 0: lumpfile, 1: lineread_script
global int 35:lumpread_filecount;
global int 34:lumpread_lastline[]; // 0: lastline, 1:lineread_script
global int 36:lumpread_bufferlinecount;
global int 33:lumpread_buffer[];
global int 37:lumpread_buffernextcomma[];

Script "LumpRead_LoadFile" (int lumpfile, int lineread_script){
    if(lumpread_initialized == true) terminate;

    lumpread_files[2*lumpread_count] = lumpfile;
    lumpread_files[2*lumpread_count + 1] = lineread_script;
    lumpread_count++;
}

Script "LumpRead_ProcessLumps" (int lumpread_id) {
    int lump = 0;
    int lumpfile = lumpread_files[2*lumpread_id];
    int lineread_script = lumpread_files[2*lumpread_id + 1];
	while (true){
		lump = LumpOpen(lumpfile, lump, 0);

		if(lump == -1) {
            break;
        }
        
        str file_text = LumpReadString(lump, 0);
        lumpread_busyfile = true;
        ACS_NamedExecuteWithResult("LumpRead_ReadFile", file_text, lineread_script, lumpread_filecount);
        lumpread_lastline[2*lumpread_filecount + 1] = lineread_script;
        lumpread_filecount++;
        while(lumpread_busyfile == true){
            //Log(s:LumpGetInfo(lump, LUMP_INFO_NAME), s:" - ", d:lump);
            delay(1);
        }
        //Log(s:LumpGetInfo(lump, LUMP_INFO_NAME), s:" - ", d:lump, s:", Processed");
        //Log(s:"Finished processing ", s:lumpfile, s:" lump. Index: ", d:lump, s:".");
        LumpClose(lump);
	}
    lumpread_busy = false;
}


Script "LumpRead_OpenFiles_Clientside" Open Clientside {
    if(GameType() != GAME_SINGLE_PLAYER)
        ACS_NamedExecuteAlways("LumpRead_OpenFiles", 0);
}

Script "LumpRead_OpenFiles" Open {
    if(lumpread_initialized == true) {
        // If already intialized when changing the map, reload the buffered lines.
        int line_loaded = 0;
        for(int i = 0; i < lumpread_filecount; i++){
            //Log(s:"File ", d:i, s:" had ", d:lumpread_lastline[2*i], s:" lines buffered.");
            for(int j = 0; j < lumpread_lastline[2*i]; j++){
                //log(s:"line buffered:", d:j, s:", line-script: '", s:lumpread_lastline[2*i + 1], s:"', total lines: ", d:lumpread_lastline[2*i], s:", content: '", s:lumpread_buffer[line_loaded + j], s:"'");
                res2 = 0; res1 = 0;
                ACS_NamedExecuteWithResult(lumpread_lastline[2*i+1], lumpread_buffer[line_loaded + j]);
                if(j % 1000 == 0){
                    delay(1); // Screw you delays on lump reading.
                }
            }
            line_loaded += lumpread_lastline[2*i];
        }
        terminate;
    }
    lumpread_bufferlinecount = 0;
    //delay(3);
    int lump = -1;
    while(lump < lumpread_count){
        if(lumpread_busy == true){
            delay(1);
        }
        lumpread_busy = true;
        lump ++;
        if(lump < lumpread_count) {
            //Log(s:"Reading: '", s:lumpread_files[2*lump], s:"' Lumps");
            ACS_NamedExecute("LumpRead_ProcessLumps", 0, lump);
        }
    }
    lumpread_initialized = true;
}

Script "LumpRead_ReadFile" (int file_text, int lineread_script, int lumpread_fileid){
    //Now let's read this file, comments with '//' or in '/**/' will be skipped.
    //str file_text = LumpReadString(lump, 0);
    //log(s:file_text);
    int tex_len = StrLen(file_text);
    int next_newline = ACS_NamedExecuteWithResult("LumpRead_FindText", file_text, "\n", 0);
    next_newline = next_newline != -1 ? next_newline : tex_len;
    int next_comment_multiline[2] = {-1, -1};
    next_comment_multiline[0] = ACS_NamedExecuteWithResult("LumpRead_FindText", file_text, "/*", 0);
    next_comment_multiline[1] = ACS_NamedExecuteWithResult("LumpRead_FindText", file_text, "*/", 0);
    if(next_comment_multiline[1] == -1) next_comment_multiline[1] = tex_len;
    int pos = 0;
    int delayer = 0;
    do{
        if(next_comment_multiline[0] != -1 && pos >= next_comment_multiline[0]){
            if (pos >= next_comment_multiline[1]){
                next_comment_multiline[0] = ACS_NamedExecuteWithResult("LumpRead_FindText", file_text, "/*", pos);
                next_comment_multiline[1] = ACS_NamedExecuteWithResult("LumpRead_FindText", file_text, "*/", pos);
                if(next_comment_multiline[1] == -1) next_comment_multiline[1] = tex_len;
            }else{
                pos = next_comment_multiline[1]+2;
                next_newline = ACS_NamedExecuteWithResult("LumpRead_FindText", file_text, "\n", pos);
                if(pos == tex_len) break;
            }
        }
        str line = StrSlice(file_text, pos, next_newline);
        ACS_NamedExecuteWithResult("LumpRead_ReadLine", line, lineread_script, lumpread_fileid);
        // go to next line
        pos = next_newline+1;
        next_newline = ACS_NamedExecuteWithResult("LumpRead_FindText", file_text, "\n", pos);
        next_newline = next_newline != -1 ? next_newline : tex_len;
        delayer ++;
        if(!(delayer % 200)) delay(1);			
    }while(pos-1 != tex_len);
    lumpread_busyfile = false;
}

Script "LumpRead_FindText" (int file_text, int char, int pos){
    // It's own script just to evade runaway errors. Because this function will be resource intensive.
    SetResultValue(StrFindFrom(file_text, char, pos));
}

Script "LumpRead_ReadLine" (int line, int lineread_script, int lumpread_fileid){
    // Each parsed line, removing comments and CR's. And then, execute the lineread_script
    int next_comment;
    int next_comment1;
    int next_comment2;
    int line_size;

    next_comment = -1;
    next_comment1 = StrFindFrom(line, "//", 0);
    next_comment2 = StrFindFrom(line, "/*", 0);
    if(next_comment1 != -1 && next_comment2 != -1) next_comment = min(next_comment1, next_comment2);
    else if(next_comment1 == -1 && next_comment2 != -1) next_comment = next_comment2;
    else if(next_comment2 == -1 && next_comment1 != -1) next_comment = next_comment1;
    line = StrRemoveCR(line); 
    if (StrLen(line) == 0) Terminate;
    line_size = StrLen(line);
    line = StrSlice(line, 0, line_size - (line_size - next_comment)*(next_comment != -1));
    if (StrLen(line) == 0) Terminate;
    line_size = StrLen(line);
    //log(s:"Pos= (", d:pos, s:"), line=(", s:line, s:")");
    //log(s:line, s:" => Pos = ", d:pos, s:", next_newline = ", d:next_newline, s:", next_comment = ", d:next_comment, s:", line_size = ", d:line_size);
    if(line_size != 0){
        //Save this line into buffered lines, for a quick re-load.
        res1 = 0; 
        res2 = 0;
        lumpread_lastline[2*lumpread_fileid]++;
        lumpread_buffer[lumpread_bufferlinecount] = line;
        //lumpread_buffernextcomma[lumpread_bufferlinecount] = res2;
        lumpread_bufferlinecount ++;
        ACS_NamedExecuteWithResult(lineread_script, line);
    }
}
function int LumpRead_CountArgs(str line, int min_args, int max_args, str command) {
    int count = 0;
    int in_quotes = 0;
    int len = StrLen(line);
    for (int i = 0; i < len; i++) {
        int ch = GetChar(line, i);
        if (ch == '"') in_quotes = !in_quotes;
        if (ch == ',' && !in_quotes) count++;
    }
    count++; // Last argument after last comma
    if (count < min_args) {
        Log(s:"(",s:command, s:"): ", s:"Not enough arguments! Expected at least ", d:min_args, s:", got ", d:count, s:".");
        return 0;
    }
    if (count > max_args) {
        Log(s:"(",s:command, s:"): ", s:"Too many arguments! Expected at most ", d:max_args, s:", got ", d:count, s:".");
        return 0;
    }
    return count;
}

function bool LumpRead_StrNextArg(str line){
    int nextcoma = StrFindFrom(line, ",", res2);
    if(nextcoma == -1){
        nextcoma = strlen(line);
    }
    
    if(res2 >= strlen(line) || res2 >= nextcoma) { 
        res1 = "";
        return false; // No more arguments
    }
    res1 = StrSlice(line, res2, nextcoma);
    res1 = StrRemoveCR(res1);
    res1 = StrTrim(res1);
    res1 = StrRemove(res1, "\"");
    res1 = StrRemove(res1, "\t");
    res2 = nextcoma+1;
    return true; // Argument found
}

function int LumpRead_NextArg(str line, int value_type) {
    if(!LumpRead_StrNextArg(line)){
        log(s:"(LumpRead_NextArg): Required Next Argument not found in pos = ", d:res2, s:", line = '", s:line, s:"'");
        return 0;
    }
    return LumpRead_ParseValue (res1, value_type);
}

function int LumpRead_NextArgDefault(str line, int value_type, int value) {
    if(!LumpRead_StrNextArg(line)) return value;
    return LumpRead_ParseValue (res1, value_type);
}

function str StrTrim(str string){
    int len = StrLen(string);
    str newstring;
    int i;
    int leftchar;
    int rightchar;
    for(i = 0; i < len; i++){
        if(GetChar(string, i) != ' '){
            leftchar = i;
            break;
        }
    }
    newstring = StrSlice(string, leftchar, len);
    len = StrLen(newstring);
    for(i = len-1; i >= 0; i--){
        if(GetChar(newstring, i) != ' '){
            rightchar = i;
            break;
        }
    }
    newstring = StrSlice(newstring, 0, rightchar+1);
    return newstring;
}

function int StrCharCount(str string, int check){
    int len = StrLen(string);
    int res = 0;
    for(int i = 0; i < len; i++){
        if(GetChar(string, i) == check){
            res++;
        }
    }
    return res;
}

function str StrRemoveCR(str string){
	return GetChar(string, StrLen(string)-1) == 13 ? StrSlice(string, 0, StrLen(string)-1) : string;
}