///////////////////////////////////////////////////
//      SHOTGUN FRENZY PLUS
//   a Shotgun Frenzy fork by Samuzero15tlh

// fl_ItemDir.acs
// item directory

// Here it lays all of the weapons on the game.
// For the prices, take a look at cvarinfo.prices lump.

#library "fl_WDir"
#import "f_intDB.acs"
#import "fl_techs.acs"
#import "fp_lumpread.acs"
#include "zcommon.acs"
#include "acsutils.acs"
#include "samu_tools.acs"

#libdefine WEAPON_SET_CATEGORIES 3
#libdefine WEAPON_SET_HIDDEN -2
#libdefine WEAPON_SET_BASIC -1
#libdefine WEAPON_SET_STANDARD 0
#libdefine WEAPON_SET_ADVANCED 1
#libdefine WEAPON_SET_OVERPOWERED 2
#libdefine WEAPON_SET_ELITE 3

#libdefine FP_WEP_PACKS_PER_CATEGORY 50
#libdefine FP_WEP_PACKS FP_WEP_PACKS_PER_CATEGORY*WEAPON_SET_CATEGORIES
#libdefine FP_WEAPONS 150*WEAPON_SET_CATEGORIES
#libdefine FP_WEAPONS_PER_PACK 3
#libdefine FP_WEPUPS 8

#libdefine FP_WDIR_WPPACK_NAME 0
#libdefine FP_WDIR_WPPACK_CATEGORY 1
#libdefine FP_WDIR_WPPACK_DESCRIPTION 2
#libdefine FP_WDIR_WPPACK_PRICE 3
#libdefine FP_WDIR_WPPACK_MONSPRESS 4
#libdefine FP_WDIR_WPPACK_WPSNUM 5
#libdefine FP_WDIR_WPPACK_LANGSTRING 6
#libdefine FP_WDIR_WPPACK_FORCLASS 7

#libdefine FP_WDIR_WEPUPG_ACTOR 0
#libdefine FP_WDIR_WEPUPG_NAME 1
#libdefine FP_WDIR_WEPUPG_DESCRIPTION 2
#libdefine FP_WDIR_WEPUPG_UPGRPRICE 3
#libdefine FP_WDIR_WEPUPG_RECYPRICE 4
#libdefine FP_WDIR_WEPUPG_UPTYPE 5

#libdefine FP_WDIR_WEAPON_ACTOR 0
#libdefine FP_WDIR_WEAPON_NAME 1
#libdefine FP_WDIR_WEAPON_PACK 2
#libdefine FP_WDIR_WEAPON_DESCRIPTION 3
#libdefine FP_WDIR_WEAPON_PRICE 4
#libdefine FP_WDIR_WEAPON_UPSNUM 5
#libdefine FP_WDIR_WEAPON_LANGSTRING 6
#libdefine FP_WDIR_WEAPON_FORCLASS 7

// Ammo definition array and constants
#libdefine FP_AMMODEFS 200
#libdefine FP_AMMODEF_PROPS 10

#libdefine FP_AMMODEF_NAME 0
#libdefine FP_AMMODEF_BASEMAX 1
#libdefine FP_AMMODEF_PBEXTRAAMMO 2
#libdefine FP_AMMODEF_DISPENSERGIVE 3
#libdefine FP_AMMODEF_SUPPLYSPAWN 4
#libdefine FP_AMMODEF_MAXCAP 5
#libdefine FP_AMMODEF_NOTEXPANDABLE 6

#libdefine FP_LANGUAGEPROP_NAME "NAME"
#libdefine FP_LANGUAGEPROP_DESC "DESC"

// Starter items array and constants
#libdefine FP_STARTER_CLASSES 50
#libdefine FP_STARTER_ITEMS_PER_CLASS 10
#libdefine FP_STARTERITEM_PROPS 10

#libdefine FP_STARTERITEM_CLASSPLAYER 0
#libdefine FP_STARTERITEM_ITEM 1
#libdefine FP_STARTERITEM_AMOUNT 2
#libdefine FP_STARTERITEM_EQUIPWEAPON 3

int fp_StarterItems[FP_STARTER_CLASSES][FP_STARTER_ITEMS_PER_CLASS][FP_STARTERITEM_PROPS];
int fp_StarterItemStack[FP_STARTER_CLASSES]; // Tracks item count for each class
str fp_StarterClassNames[FP_STARTER_CLASSES];
int fp_StarterClassCount = 0;

int fp_WpPacks[FP_WEP_PACKS][10];
int fp_Wpns[FP_WEAPONS][10];
int fp_WpUps[FP_WEAPONS][FP_WEPUPS][10];

int fp_WpCategory[WEAPON_SET_CATEGORIES][50];
int fp_WpCategoryStack[WEAPON_SET_CATEGORIES];
int fp_AmmoList[FP_AMMODEFS][FP_AMMODEF_PROPS];

int term_catStyle[WEAPON_SET_CATEGORIES][2];

#libdefine TERM_CATSTYLE_TEXT 0
#libdefine TERM_CATSTYLE_COLOR 1

// Weapon pack tracker. For difficulty increasing.
int fp_WpTrack[FP_WEP_PACKS];
int fp_UpTrack;


// Saved weapons per each player.
int fp_WpnsPerPlayer[32][FP_WEAPONS];

int fp_WeaponPackStack;
int fp_WeaponStack = 0;
int fp_AmmoDefStack = 0;

// fp_WeaponPacks
//	Pack name
//	Category (BAS, ADV, POW)
//  Description
// 	Buy Price

// fp_Wpns[wepaonid]:
//  Score Gain (To ramp-up difficulty.)
// 	Weapon Name
// 	Actor
// 	Pack id
//  Description
// 	Recycle Price (On Credits)

// fp_WeaponUpgrades[wepaonid]:
// 	Weapon Upgrade Name
// 	Actor
//  Description
// 	Upgrade Price (On Ups.)

function void SFPlus_DefineWeapons (void){
	int wep = 0;
	int pack = 0;
	int ups = 0;
	str string;
	
	fp_WeaponPackStack = 0;
	fp_WeaponStack = 0;
	fp_WpCategoryStack[0] = 0;
	fp_WpCategoryStack[1] = 0;
	fp_WpCategoryStack[2] = 0;

	term_catStyle[WEAPON_SET_STANDARD][TERM_CATSTYLE_COLOR] = CR_GREEN;
	term_catStyle[WEAPON_SET_STANDARD][TERM_CATSTYLE_TEXT] = "Standard";
	term_catStyle[WEAPON_SET_ADVANCED][TERM_CATSTYLE_COLOR] = CR_CYAN;
	term_catStyle[WEAPON_SET_ADVANCED][TERM_CATSTYLE_TEXT] = "Advanced";
	term_catStyle[WEAPON_SET_OVERPOWERED][TERM_CATSTYLE_COLOR] = CR_ORANGE;
	term_catStyle[WEAPON_SET_OVERPOWERED][TERM_CATSTYLE_TEXT] = "Overpowered";

	WDir_ReadSFWEPDEF();
}

function void WDir_ReadSFWEPDEF(void){
	ACS_NamedExecuteWithResult("LumpRead_LoadFile", "SFWEPDEF", "SFPlus_WDir_SFWEPDEFReadLine");
}

int file_wpid;
int file_wepid;

function int StarterClass_FindOrAdd(str classPlayer) {
	for (int i = 0; i < fp_StarterClassCount; i++) {
		if (StrEquals(fp_StarterClassNames[i], classPlayer)) {
			return i;
		}
	}
	// Not found, add new class if space
	if (fp_StarterClassCount < FP_STARTER_CLASSES) {
		fp_StarterClassNames[fp_StarterClassCount] = classPlayer;
		fp_StarterClassCount++;
		return fp_StarterClassCount - 1;
	}
	return -1; // No space left
}

Script "SFPlus_WDir_SFWEPDEFReadLine" (int line) {
	//log(s:"\"", s:line, s:"\"");
	str op = LumpRead_NextArg(line, LUMPR_VALUE_STR);
	//log(s:"OP: ", s:op);
	int argcount = StrCharCount(line, ",")+1;
	if(StrIEquals(op, "AddWeaponPack")){
		SFWEPDEF_AddWeaponPack(line);
	} else if(StrIEquals(op, "AddWeapon")){
		SFWEPDEF_AddWeapon(line, false);
	} else if(StrIEquals(op, "AddWeaponNoPack")){
		SFWEPDEF_AddWeapon(line, true);
	} else if(StrIEquals(op, "AddWeaponUp")){
		SFWEPDEF_AddWeaponUpgrade(line);
	} else if(StrIEquals(op, "ClearAllWeapons")){
		SFWEPDEF_ClearAllWeapons();
	} else if(StrIEquals(op, "ReplaceWeapon")){
		SFWEPDEF_ReplaceWeapon(line);
	} else if(StrIEquals(op, "ReplaceWeaponPack")){
		SFWEPDEF_ReplaceWeaponPack(line);
	} else if(StrIEquals(op, "ReplaceWeaponUp")){
		SFWEPDEF_ReplaceWeaponUpgrade(line);
	} else if(StrIEquals(op, "AddAmmo")){
		SFWEPDEF_AddAmmo(line);
	} else if(StrIEquals(op, "ClearAllAmmo")){
		SFWEPDEF_ClearAllAmmo();
	} else if(StrIEquals(op, "StarterItem")){
		SFWEPDEF_StarterItem(line);
	} else if(StrIEquals(op, "ClearClasses")){
		SFWEPDEF_ClearClasses();
	}
	else {
		log(s:"fl_WDir: Invalid command: '", s:op, s:"'", s:", line=", s:line);
	}
}

function void SFWEPDEF_ClearClasses (void){
	// Clear all starter classes and their items
	for(int c = 0; c < fp_StarterClassCount; c++) {
		fp_StarterClassNames[c] = "";
		for(int i = 0; i < FP_STARTER_ITEMS_PER_CLASS; i++) {
			for(int j = 0; j < FP_STARTERITEM_PROPS; j++) {
				fp_StarterItems[c][i][j] = 0;
			}
		}
		fp_StarterItemStack[c] = 0;
	}
	fp_StarterClassCount = 0;
}

function void SFWEPDEF_ClearAllWeapons(void) {
	int i, j, k;
	for(i = 0; i < FP_WEP_PACKS; i++){
		for(j = 0; j < 10; j++){
			fp_WpPacks[i][j] = 0;
		}
	}
	for(i = 0; i < FP_WEAPONS; i++){
		Weapon_Clear(i);
	}

	for(i = 0; i < WEAPON_SET_CATEGORIES; i++){
		for(j = 0; j < 50; j++){
			fp_WpCategory[i][j] = 0;
		}
		fp_WpCategoryStack[i] = 0;
	}

	fp_WeaponPackStack = 0;
	fp_WeaponStack = 0;
}

function void Weapon_Clear(int weapon_id){
	int j;
	for(j = 0; j < 10; j++){
		fp_Wpns[weapon_id][j] = 0;
	}
	WeaponUpgrades_Clear(weapon_id);
}

function void WeaponUpgrades_Clear(int weapon_id){
	int j, k;
	fp_Wpns[weapon_id][FP_WDIR_WEAPON_UPSNUM] = 0;
	for(j = 0; j < FP_WEPUPS; j++){
		for(k = 0; k < 10; k++){
			fp_WpUps[weapon_id][j][k] = 0;
		}
	}
}

/*  Adds an ammo definition  */
function void SFWEPDEF_AddAmmo(int line) {
	if(!LumpRead_CountArgs (line, 4, 8, "AddAmmo")) return; // 6 LumpRead_NextArg

	str ammo_name = LumpRead_NextArg(line, LUMPR_VALUE_STR);
	int base_max_amount = LumpRead_NextArg(line, LUMPR_VALUE_INT);
	int pb_extra_ammo = LumpRead_NextArg(line, LUMPR_VALUE_INT);
	int dispenser_give = LumpRead_NextArgDefault(line, LUMPR_VALUE_INT, 1);
	int supply_spawn = LumpRead_NextArgDefault(line, LUMPR_VALUE_STR, 0);
	int max_cap = LumpRead_NextArgDefault(line, LUMPR_VALUE_INT, 0);
	bool dont_expand = LumpRead_NextArgDefault(line, LUMPR_VALUE_BOOL, false);

	int idx = fp_AmmoDefStack;
	if(idx < FP_AMMODEFS) {
		fp_AmmoList[idx][FP_AMMODEF_NAME] = ammo_name;
		fp_AmmoList[idx][FP_AMMODEF_BASEMAX] = base_max_amount;
		fp_AmmoList[idx][FP_AMMODEF_PBEXTRAAMMO] = pb_extra_ammo;
		fp_AmmoList[idx][FP_AMMODEF_DISPENSERGIVE] = dispenser_give;
		fp_AmmoList[idx][FP_AMMODEF_SUPPLYSPAWN] = supply_spawn;
		fp_AmmoList[idx][FP_AMMODEF_MAXCAP] = max_cap;
		fp_AmmoList[idx][FP_AMMODEF_NOTEXPANDABLE] = dont_expand;
		fp_AmmoDefStack++;
	} else {
		log(s:"AddAmmo: Maximum ammo definitions reached (", d:FP_AMMODEFS, s:").");
	}
}

/*  Clears all defined ammo  */
function void SFWEPDEF_ClearAllAmmo(void) {
	for(int i = 0; i < FP_AMMODEFS; i++) {
		for(int j = 0; j < FP_AMMODEF_PROPS; j++) {
			fp_AmmoList[i][j] = 0;
		}
	}
	fp_AmmoDefStack = 0;
}

function void AmmoTakeLeftOvers (str ammo){
	if(getAmmoCapacity(ammo) < CheckInventory(ammo)){
		TakeInventory(ammo, CheckInventory(ammo) - getAmmoCapacity(ammo));
	}
}

script "Ammo_UpdateCaps" (void) {
	int p_back = CheckInventory("p_Backpack");
	int g_back = (CheckInventory("g_Backpack") || CheckInventory("Cheat_Ammo"));
	int ammo_rune = CheckInventory("RuneAmmunition");

	for (int i = 0; i < fp_AmmoDefStack; i++) {
		str ammo_name = fp_AmmoList[i][FP_AMMODEF_NAME];
		int base_max_amount = fp_AmmoList[i][FP_AMMODEF_BASEMAX];
		int max_cap = fp_AmmoList[i][FP_AMMODEF_MAXCAP];
		bool dont_expand = fp_AmmoList[i][FP_AMMODEF_NOTEXPANDABLE];
		int pbextra_ammo = fp_AmmoList[i][FP_AMMODEF_PBEXTRAAMMO];

		int cap = base_max_amount;
		if (!dont_expand) {
			cap = base_max_amount + (base_max_amount * g_back + pbextra_ammo * p_back);
			if (ammo_rune) {
				cap = cap * 3 / 2; // Multiply by 1.5 if ammo_rune is active
			}
		}
		// If max_cap is not zero, limit cap to max_cap
		if (max_cap != 0 && cap > max_cap) {
			cap = max_cap;
		}
		SetAmmoCapacity(ammo_name, cap);
		AmmoTakeLeftOvers(ammo_name);
	}
}

script "Ammo_ResetCaps" (void) {
	TakeInventory("p_Backpack", 1); // Reset token.
	TakeInventory("g_Backpack", 1); // Reset token.

	for (int i = 0; i < fp_AmmoDefStack; i++) {
		str ammo_name = fp_AmmoList[i][FP_AMMODEF_NAME];
		int base_max_amount = fp_AmmoList[i][FP_AMMODEF_BASEMAX];
		SetAmmoCapacity(ammo_name, base_max_amount);
	}
}

script "SFPlus_WDir_GiveStarterItems" (void)
{
	// Clear inventory first
	ClearInventory();

	// Get player's class name
	str currentPlayerClass = GetActorClass(990 + PlayerNumber());

	// Find matching class index
	int classIdx = -1;
	for (int i = 0; i < fp_StarterClassCount; i++)
	{
		if (StrEquals(fp_StarterClassNames[i], currentPlayerClass))
		{
			classIdx = i;
			break;
		}
	}

	// If found, give starter items
	if (classIdx != -1)
	{
		for (int j = 0; j < fp_StarterItemStack[classIdx]; j++)
		{
			str item = fp_StarterItems[classIdx][j][FP_STARTERITEM_ITEM];
			int amount = fp_StarterItems[classIdx][j][FP_STARTERITEM_AMOUNT];
			bool equipWeapon = fp_StarterItems[classIdx][j][FP_STARTERITEM_EQUIPWEAPON];
			if (item != "")
			{
				GiveInventory(item, amount);
				if (equipWeapon)
				{
					delay(1);
					SetWeapon(item); // If it is a weapon, set it as the current weapon
				}
			}
		}
	}
}

/*	Adds a weapon pack	*/
function void SFWEPDEF_AddWeaponPack (int line) {
	if(!LumpRead_CountArgs (line, 6, 6, "AddWeaponPack")) return;

	int cat = LumpRead_NextArg (line, LUMPR_VALUE_INT);
	if(fp_WpCategoryStack[cat] >= FP_WEP_PACKS_PER_CATEGORY){
		log(s:"(FL_WDIR.acs) Can't add more weapon packs in this category, ", d:FP_WEP_PACKS_PER_CATEGORY, s:" packs Limit reached.");
		return;
	}
	int wpid = fp_WeaponPackStack;

	//int wid = lumpread_value_buffer[0];
	fp_WpCategory[cat][fp_WpCategoryStack[cat]] = wpid;
	fp_WpCategoryStack[cat]++;
	//log(s:"Category stack: ", d:fp_WpCategoryStack[cat]);
	fp_WpPacks[wpid][FP_WDIR_WPPACK_CATEGORY] = cat;

	fp_WpPacks[wpid][FP_WDIR_WPPACK_LANGSTRING] = strparam(s:LumpRead_NextArg (line, LUMPR_VALUE_STR));
	str lang_weppack = fp_WpPacks[wpid][FP_WDIR_WPPACK_LANGSTRING];

	fp_WpPacks[wpid][FP_WDIR_WPPACK_NAME] = SFWEPDEF_WepLanguageValue (lang_weppack, FP_LANGUAGEPROP_NAME);
	fp_WpPacks[wpid][FP_WDIR_WPPACK_DESCRIPTION] = SFWEPDEF_WepLanguageValue (lang_weppack, FP_LANGUAGEPROP_DESC);
	fp_WpPacks[wpid][FP_WDIR_WPPACK_PRICE] = LumpRead_NextArg (line, LUMPR_VALUE_CVAR);
	fp_WpPacks[wpid][FP_WDIR_WPPACK_MONSPRESS] = LumpRead_NextArg (line, LUMPR_VALUE_INT);
	fp_WpPacks[wpid][FP_WDIR_WPPACK_FORCLASS] = LumpRead_NextArgDefault (line, LUMPR_VALUE_STR, 0);
	fp_WeaponPackStack++;
}

/*	Adds a weapon  */
function void SFWEPDEF_AddWeapon (int line, bool nopack) {
	if(!LumpRead_CountArgs (line, 5, 7, "AddWeaponPack")) return; // 5 LumpRead_NextArg

	int weapon_pack_id = -1;
	if(!nopack){
		weapon_pack_id = WeaponPack_Find(LumpRead_NextArg(line, LUMPR_VALUE_STR));
	}
	int wepid = fp_WeaponStack;
	fp_Wpns[wepid][FP_WDIR_WEAPON_ACTOR] = LumpRead_NextArg (line, LUMPR_VALUE_STR);
	str lang_wep = LumpRead_NextArg (line, LUMPR_VALUE_STR);
	fp_Wpns[wepid][FP_WDIR_WPPACK_LANGSTRING] = lang_wep;
	fp_Wpns[wepid][FP_WDIR_WEAPON_PACK] = weapon_pack_id;

	if(weapon_pack_id >= 0) {
		// If the weapon is part of a pack, we need to get the language string from the pack.
		str lang_weppack = fp_WpPacks[weapon_pack_id][FP_WDIR_WPPACK_LANGSTRING];
		lang_wep = strparam(s:lang_weppack, s:"_", s:lang_wep);
		fp_Wpns[wepid][FP_WDIR_WEAPON_LANGSTRING] = lang_wep;
	} 

	fp_Wpns[wepid][FP_WDIR_WEAPON_NAME] = SFWEPDEF_WepLanguageValue (lang_wep, FP_LANGUAGEPROP_NAME);
	fp_Wpns[wepid][FP_WDIR_WEAPON_DESCRIPTION] = SFWEPDEF_WepLanguageValue (lang_wep, FP_LANGUAGEPROP_DESC);
	
	 // Ignoring Icon argument for now.
	LumpRead_NextArg (line, LUMPR_VALUE_STR);
	
	if(weapon_pack_id >= 0) 
		fp_Wpns[wepid][FP_WDIR_WEAPON_PRICE] = LumpRead_NextArg (line, LUMPR_VALUE_CVAR);

	fp_WeaponStack++;
}

/*	Adds a weapon upgrade	*/
function void SFWEPDEF_AddWeaponUpgrade(int line){
	if(!LumpRead_CountArgs (line, 6, 6, "AddWeaponUp")) {
		log(s:line);
		return; // 6 LumpRead_NextArg
	}

	str base_weapon_actor = LumpRead_NextArg(line, LUMPR_VALUE_STR);
	int weapon_id = Weapon_Find(base_weapon_actor);
	int uptype = LumpRead_NextArg (line, LUMPR_VALUE_INT);
	if(weapon_id == -1){
		log(s:"(FL_WDIR.acs) Base weapon '", s:base_weapon_actor, s:"' not found, cannot add Type ", d:uptype, s:" upgrade.");
		return;
	}
	int wepup_count = fp_Wpns[weapon_id][FP_WDIR_WEAPON_UPSNUM];
	if(wepup_count >= FP_WEPUPS){
		log(s:"(FL_WDIR.acs) Can't add more weapon upgrades for this weapon, ", d:FP_WEPUPS, s:" weapons Limit reached.");
		return;
	}
	str lang_wep = fp_Wpns[weapon_id][FP_WDIR_WEAPON_LANGSTRING];
	

	fp_WpUps[weapon_id][wepup_count][FP_WDIR_WEPUPG_UPTYPE] = uptype;
	fp_WpUps[weapon_id][wepup_count][FP_WDIR_WEPUPG_ACTOR] = LumpRead_NextArg (line, LUMPR_VALUE_STR);
	fp_WpUps[weapon_id][wepup_count][FP_WDIR_WEPUPG_NAME] = SFWEPDEF_WepLangVal_Upgrade (lang_wep, uptype, FP_LANGUAGEPROP_NAME);
	fp_WpUps[weapon_id][wepup_count][FP_WDIR_WEPUPG_DESCRIPTION] = SFWEPDEF_WepLangVal_Upgrade (lang_wep, uptype, FP_LANGUAGEPROP_DESC);
	//log(s:"Description: ", s:fp_WpUps[file_wepid][wepup_count][FP_WDIR_WEPUPG_DESCRIPTION]);
	fp_WpUps[weapon_id][wepup_count][FP_WDIR_WEPUPG_UPGRPRICE] = LumpRead_NextArg (line, LUMPR_VALUE_CVAR);
	fp_WpUps[weapon_id][wepup_count][FP_WDIR_WEPUPG_RECYPRICE] = LumpRead_NextArg (line, LUMPR_VALUE_CVAR);
	fp_Wpns[weapon_id][FP_WDIR_WEAPON_UPSNUM]++;
}

/*	Replaces a weapon pack	*/
function void SFWEPDEF_ReplaceWeaponPack(int line) {
	if(!LumpRead_CountArgs (line, 6, 7, "ReplaceWeaponPack")) return; // 7 LumpRead_NextArg

	int i = 0;
	str pack_to_replace = LumpRead_NextArg(line, LUMPR_VALUE_STR);
	str pack_replacer = LumpRead_NextArg(line, LUMPR_VALUE_STR);
	int new_category = LumpRead_NextArg(line, LUMPR_VALUE_INT);
	int pack_to_replace_id = WeaponPack_Find(pack_to_replace);

	if(pack_to_replace_id == -1){
		log(s:"(FL_WDIR.acs) Replaced weapon pack '", s:pack_to_replace, s:"' not found. Failed to replace with: '", s:pack_replacer, s:"'.");
		return;
	}

	file_wpid = pack_to_replace_id;

	for(i = 0; i < FP_WEAPONS && pack_to_replace_id != -1; i++){
		if(Weapon_GetWepPack(i) == pack_to_replace_id){
			Weapon_Clear(i);
		}
	}

	fp_WpPacks[file_wpid][FP_WDIR_WPPACK_LANGSTRING] = pack_replacer;
	str lang_weppack = fp_WpPacks[file_wpid][FP_WDIR_WPPACK_LANGSTRING];

	// Set category if new_category > -2, otherwise keep original
	if(new_category > WEAPON_SET_HIDDEN) {
		fp_WpPacks[file_wpid][FP_WDIR_WPPACK_CATEGORY] = new_category;
	}
	// else: keep the original category

	fp_WpPacks[file_wpid][FP_WDIR_WPPACK_NAME] = SFWEPDEF_WepLanguageValue(lang_weppack, FP_LANGUAGEPROP_NAME);
	fp_WpPacks[file_wpid][FP_WDIR_WPPACK_DESCRIPTION] = SFWEPDEF_WepLanguageValue(lang_weppack, FP_LANGUAGEPROP_DESC);
	fp_WpPacks[file_wpid][FP_WDIR_WPPACK_PRICE] = LumpRead_NextArg(line, LUMPR_VALUE_CVAR);
	fp_WpPacks[file_wpid][FP_WDIR_WPPACK_MONSPRESS] = LumpRead_NextArg(line, LUMPR_VALUE_INT);
	fp_WpPacks[file_wpid][FP_WDIR_WPPACK_FORCLASS] = LumpRead_NextArgDefault (line, LUMPR_VALUE_STR, 0);
}

/*	Replaces a weapon	*/
function void SFWEPDEF_ReplaceWeapon(int line) {
	if(!LumpRead_CountArgs (line, 7, 7, "ReplaceWeapon")) return;

	int i = 0;
	str weapon_to_replace = LumpRead_NextArg (line, LUMPR_VALUE_STR);
	str weapon_replacer = LumpRead_NextArg (line, LUMPR_VALUE_STR);
	int wepid = Weapon_Find(weapon_to_replace);

	if(wepid == -1){
		log(s:"(FL_WDIR.acs) Replaced weapon '", s:weapon_to_replace, s:"' not found. Failed to replace with: '", s:weapon_replacer, s:"'.");
		return;
	}
	int wep_pack_id = Weapon_GetWepPack(wepid);
	WeaponUpgrades_Clear(wepid);

	fp_Wpns[wepid][FP_WDIR_WEAPON_PACK] = wep_pack_id;
	fp_Wpns[wepid][FP_WDIR_WEAPON_ACTOR] = weapon_replacer;
	str lang_wep = LumpRead_NextArg (line, LUMPR_VALUE_STR);
	fp_Wpns[wepid][FP_WDIR_WPPACK_LANGSTRING] = lang_wep;

	if(wep_pack_id >= 0) {
		// If the weapon is part of a pack, we need to get the language string from the pack.
		str lang_weppack = fp_WpPacks[wep_pack_id][FP_WDIR_WPPACK_LANGSTRING];
		lang_wep = strparam(s:lang_weppack, s:"_", s:lang_wep);
		fp_Wpns[wepid][FP_WDIR_WEAPON_LANGSTRING] = lang_wep;
	} 

	fp_Wpns[wepid][FP_WDIR_WEAPON_NAME] = SFWEPDEF_WepLanguageValue (lang_wep, FP_LANGUAGEPROP_NAME);
	fp_Wpns[wepid][FP_WDIR_WEAPON_DESCRIPTION] = SFWEPDEF_WepLanguageValue (lang_wep, FP_LANGUAGEPROP_DESC);

	LumpRead_NextArg (line, LUMPR_VALUE_STR);
	
	if(wep_pack_id >= 0) 
		fp_Wpns[file_wepid][FP_WDIR_WEAPON_PRICE] = LumpRead_NextArg (line, LUMPR_VALUE_CVAR);
	
	fp_Wpns[file_wepid][FP_WDIR_WEAPON_FORCLASS] = LumpRead_NextArg (line, LUMPR_VALUE_STR);
}

function void SFWEPDEF_ReplaceWeaponUpgrade(int line) {
	if(!LumpRead_CountArgs (line, 6, 6, "ReplaceWeaponUp")) return; // 6 LumpRead_NextArg

	int i, j = 0;
	str parent_weapon = LumpRead_NextArg (line, LUMPR_VALUE_STR);
	str wepup_to_replace = LumpRead_NextArg (line, LUMPR_VALUE_INT);
	str wepup_actor_replacer = LumpRead_NextArg (line, LUMPR_VALUE_STR);
	
	int weapon_parent_id = Weapon_Find(parent_weapon);
	int wepup_to_replace_id = WeaponUpgrade_Find(weapon_parent_id, wepup_to_replace);

	if(weapon_parent_id == -1){
		log(s:"(FL_WDIR.acs) Parent weapon '", s:parent_weapon, s:"' not found. Failed to replace weapon upgrade.");
		return;
	}

	if(wepup_to_replace_id == -1){
		log(s:"(FL_WDIR.acs) Replaced weapon upgrade Type '", d:wepup_to_replace, s:"' not found in weapon '", s:parent_weapon, s:"'. Failed to replace with: '", s:wepup_actor_replacer, s:"'.");
		return;
	}

	str lang_wep = fp_Wpns[weapon_parent_id][FP_WDIR_WEAPON_LANGSTRING];
	int uptype = wepup_to_replace;

	fp_WpUps[weapon_parent_id][wepup_to_replace_id][FP_WDIR_WEPUPG_UPTYPE] = uptype;
	fp_WpUps[weapon_parent_id][wepup_to_replace_id][FP_WDIR_WEPUPG_ACTOR] = wepup_actor_replacer;
	fp_WpUps[weapon_parent_id][wepup_to_replace_id][FP_WDIR_WEPUPG_NAME] = SFWEPDEF_WepLangVal_Upgrade (lang_wep, uptype, FP_LANGUAGEPROP_NAME);
	fp_WpUps[weapon_parent_id][wepup_to_replace_id][FP_WDIR_WEPUPG_DESCRIPTION] = SFWEPDEF_WepLangVal_Upgrade (lang_wep, uptype, FP_LANGUAGEPROP_DESC);
	fp_WpUps[weapon_parent_id][wepup_to_replace_id][FP_WDIR_WEPUPG_UPGRPRICE] = LumpRead_NextArg (line, LUMPR_VALUE_CVAR);
	fp_WpUps[weapon_parent_id][wepup_to_replace_id][FP_WDIR_WEPUPG_RECYPRICE] = LumpRead_NextArg (line, LUMPR_VALUE_CVAR);
}

function void SFWEPDEF_StarterItem(int line){
	if(!LumpRead_CountArgs (line, 4, 5, "StarterItem")) return; // 3 LumpRead_NextArg, 1 LumpRead_NextArgDefault

	str classPlayer = LumpRead_NextArg(line, LUMPR_VALUE_STR);
	str inventoryItem = LumpRead_NextArg(line, LUMPR_VALUE_STR);
	int amount = LumpRead_NextArg(line, LUMPR_VALUE_INT);
	bool equipweapon = LumpRead_NextArgDefault(line, LUMPR_VALUE_BOOL, false);

	int classIdx = StarterClass_FindOrAdd(classPlayer);
	if(classIdx == -1) {
		log(s:"StarterItem: Maximum player classes reached.");
		return;
	}
	int itemIdx = fp_StarterItemStack[classIdx];
	if(itemIdx < FP_STARTER_ITEMS_PER_CLASS) {
		fp_StarterItems[classIdx][itemIdx][FP_STARTERITEM_CLASSPLAYER] = classPlayer;
		fp_StarterItems[classIdx][itemIdx][FP_STARTERITEM_ITEM] = inventoryItem;
		fp_StarterItems[classIdx][itemIdx][FP_STARTERITEM_AMOUNT] = amount;
		fp_StarterItems[classIdx][itemIdx][FP_STARTERITEM_EQUIPWEAPON] = equipweapon;
		fp_StarterItemStack[classIdx]++;
	} else {
		log(s:"StarterItem: Maximum starter items reached for class ", d:classIdx, s:".");
	}
}

function str SFWEPDEF_WepLangVal_Upgrade (str string, int up_type, str prop){
	return SFWEPDEF_WepLanguageValue (strparam(s:string, s:"_UP", d:up_type), prop);
}

function str SFWEPDEF_WepLanguageValue (str string, str prop){
	return strparam(l:strparam(s:"WEPS_", s:string, s:"_", s:prop));
}

function int GiveActorReplacedInventory(int tid, str item, int amt)
{
    int tempTid = UniqueTID();
    int ret = SpawnForced(item, GetActorX(tid), GetActorY(tid), GetActorZ(tid), tempTid, 0);
    if(ret)
    {
        GiveActorInventory(tid, GetActorClass(tempTid), amt);
        Thing_Remove(tempTid);
    }
    return ret;
}

function str Weapon_GetSameKind(int wid){
	if (CheckInventory(Weapon_GetActor(wid))) return Weapon_GetActor(wid);
	if (CheckInventory(WeaponUpgrade_getActor(wid, 0))) return WeaponUpgrade_getActor(wid, 0);
	if (CheckInventory(WeaponUpgrade_getActor(wid, 1))) return WeaponUpgrade_getActor(wid, 1);
	return 0;
}

function void Weapon_Swap(str this, str withThis){
	TakeInventory(this,1);
	GiveInventory(withThis,1);
	setWeapon(withThis);
}

function void Weapon_Upgrade(int wid, int type){
	//printbold(n:(playernumber() + 1), s:" Upgrades ", s:Weapon_GetActor(wid), s:" to: ", s:WeaponUpgrade_getActor(wid, type-1));
	Weapon_Swap(Weapon_GetActor(wid),WeaponUpgrade_getActor(wid, type));
}

function void WeaponPack_Give(int wp){
	SetActivatorToPlayer(PlayerNumber());
	for (int i = fp_WeaponStack; i >= 0 ; i--){
		if(Weapon_getWepPack(i) == wp){
			str weapon = Weapon_getActor(i);
			//giveinventory(weapon, 1);
			GiveActorReplacedInventory(ActivatorTID(), weapon, 1);
			setweapon(weapon);
		}
	}
	WPTrack_Increase(wp);
}


function void Weapon_Recycle(int wid, int upg, int play){
	str whatweapon;
	int rcyprice;
	if(upg != -1){
		whatweapon = WeaponUpgrade_GetActor(wid, upg);
		rcyprice = WeaponUpgrade_getRcyPrice(wid, upg);
	}else{ 
		whatweapon = Weapon_getActor(wid);
		rcyprice = Weapon_getPrice(wid);
	}
	
	SetActivatorToPlayer(play);
	TakeInventory(whatWeapon, 1);
	sf_AddCredits(rcyprice, play);
}




// Definers.
///////////////////////////////////////////////////////////////////////////////

function bool Weapon_IsNotUpgraded(int asThis){
	int ihavebaseweapon = checkinventory(Weapon_GetActor(asThis));
	int ihaveanyupgrade = false;
	for(int i = 0; i < Weapon_getUpsNum(asThis) && !ihaveanyupgrade; i++){
		ihaveanyupgrade = checkinventory(WeaponUpgrade_getActor(asThis, i));
	}
	return ihavebaseweapon && !ihaveanyupgrade;
}

function bool Weapon_OwnedSameKind(int asThis){
	bool iGotItUpgraded = false;
	for(int i = 0; i < Weapon_getUpsNum(asThis) && !iGotItUpgraded; i++){
		iGotItUpgraded = CheckInventory(WeaponUpgrade_getActor(asThis, i));
	}
	return checkinventory(Weapon_GetActor(asThis)) || iGotItUpgraded;
}

function int Weapon_SaveLastUsed(void){
	int res = -1;
	for(int i = 0; i < fp_weaponStack; i++){
		if(Weapon_OwnedSameKind(i)){
			res = i;
			break;
		}
	}
	//log(s:"Weapon style save: ", s:Weapon_GetActor(res));
	return res;
}

function void Weapon_LoadLastUsed(int which){
	
	SetWeapon(Weapon_GetActor(which));
	SetWeapon(WeaponUpgrade_GetActor(which, 0));
	SetWeapon(WeaponUpgrade_GetActor(which, 1));
	for(int i = 0; i < Weapon_getUpsNum(which); i++){
		SetWeapon(WeaponUpgrade_GetActor(which, i));
	}
	//log(s:"Weapon style load: ", s:Weapon_GetActor(which));
	
}

function void WPTrack_Increase(int wp){
	int cat = WeaponPack_GetCat(wp);
	fp_WPTrack[wp] = fp_WPTrack[wp] + WeaponPack_GetScoreGain(wp);
}

function void WPTrack_Decrease(int wp){
	int cat = WeaponPack_GetCat(wp);
	fp_WPTrack[wp] = fp_WPTrack[wp] - WeaponPack_GetScoreGain(wp);
}

function int WPTrack_GetScore(void){
	int i, c;
	int score = 0;
	for(i = 0; i < fp_WeaponPAckStack; i++){
		score = score + fp_WPTrack[i];
	}
	
	int players = 0;
	for(i = 0; i < 64; i++){
		if(PlayerInGame(i)) players++;
		else break;
	}
	if(!players) return 0;
	return score / players;
}

function int UpTrack_GetScore(void){
	int i;
	int score = fp_UpTrack;
	int players = 0;
	
	for(i = 0; i < 64; i++){
		if(PlayerInGame(i)) players++;
		else break;
	}
	if(!players) return 0;
	return score / players;
}

function str WeaponUpgrade_GetActor(int wpb, int uid){return fp_WpUps[wpb][uid][FP_WDIR_WEPUPG_ACTOR]; }
function str WeaponUpgrade_GetName( int wpb, int uid){ return fp_WpUps[wpb][uid][FP_WDIR_WEPUPG_NAME]; }
function int WeaponUpgrade_GetDesc(int wpb, int uid){  return fp_WpUps[wpb][uid][FP_WDIR_WEPUPG_DESCRIPTION]; }
function int WeaponUpgrade_GetUpgPrice(int wpb, int uid){ return fp_WpUps[wpb][uid][FP_WDIR_WEPUPG_UPGRPRICE]; }
function int WeaponUpgrade_GetRcyPrice(int wpb, int uid){ return fp_WpUps[wpb][uid][FP_WDIR_WEPUPG_RECYPRICE]; }
function int WeaponUpgrade_GetUpType(int wpb, int uid){ return fp_WpUps[wpb][uid][FP_WDIR_WEPUPG_UPTYPE]; }
function int WeaponUpgrade_Find(int weapon_parent_id, int up_type) {
	//log(s:"Weapon ups for weapon #", d:weapon_parent_id, s:": ", d:Weapon_getUpsNum(weapon_parent_id));
	for(int i = 0; i < Weapon_getUpsNum(weapon_parent_id); i++){
		log(d:i);
		if(up_type == WeaponUpgrade_GetUpType(weapon_parent_id, i)){
			//log(d:i, s:", That's the target");
			return i;
		}
	}
	return -1;
}


function str WeaponPack_GetLangString(int wid){  return fp_WpPacks[wid][FP_WDIR_WPPACK_LANGSTRING]; }
function str WeaponPack_GetName(int wid){  return fp_WpPacks[wid][FP_WDIR_WPPACK_NAME]; }
// Where should i find the category hmmm?
function int WeaponPack_GetCat(int wid){  return fp_WpPacks[wid][FP_WDIR_WPPACK_CATEGORY]; }
function int WeaponPack_GetScoreGain(int wid){   return fp_WpPacks[wid][FP_WDIR_WPPACK_MONSPRESS]; }
function str WeaponPack_GetDesc(int wid){  return fp_WpPacks[wid][FP_WDIR_WPPACK_DESCRIPTION]; }
function int WeaponPack_GetPrice(int wid){ return fp_WpPacks[wid][FP_WDIR_WPPACK_PRICE]; }
function int WeaponPack_GetForClass(int wid){ return fp_WpPacks[wid][FP_WDIR_WPPACK_FORCLASS]; }
function bool WeaponPack_IsEquipableForPClass(int wid){ 
	int forplayerclass = WeaponPack_GetForClass(wid);

	if(forplayerclass == 0 || StrIEquals(forplayerclass, "0")) return true;
	//log(s:"[WeaponPack_IsEquipableForPClass] forplayerclass: '", s:forplayerclass, s:"', playerclass: '", s:GetActorClass(990 + PlayerNumber()), s:"'");
	return StrContainsI(forplayerclass, GetActorClass(990 + PlayerNumber()));
}
function bool WeaponPack_isOwned(int wid){
	bool res = false;
		for (int i = 0; (i < fp_WeaponStack) && !res; i++){
			if(Weapon_getWepPack(i) == wid){
				res = Weapon_OwnedSameKind(i);
			}
		}
	return res;
}
function int WeaponPack_Find(str langstring) {
	for(int i = 0; i < FP_WEP_PACKS; i++){
		if(StrEquals(langstring, WeaponPack_GetLangString(i))){
			return i;
		}
	}
	return -1;
}

function str Weapon_GetActor(int wid){   return fp_Wpns[wid][FP_WDIR_WEAPON_ACTOR]; }
function str Weapon_GetName(int wid){    return fp_Wpns[wid][FP_WDIR_WEAPON_NAME]; }
function int Weapon_GetWepPack(int wid){ return fp_Wpns[wid][FP_WDIR_WEAPON_PACK]; }
function int Weapon_GetCat(int wid){
	return WeaponPack_GetCat(Weapon_GetWepPack(wid));
}
function int Weapon_getUpsNum(int wid){	 return fp_Wpns[wid][FP_WDIR_WEAPON_UPSNUM]; }
function int Weapon_GetDesc(int wid){    return fp_Wpns[wid][FP_WDIR_WEAPON_DESCRIPTION]; }
function int Weapon_GetPrice(int wid){   return fp_Wpns[wid][FP_WDIR_WEAPON_PRICE]; }
function int Weapon_GetForClass(int wid){   return fp_Wpns[wid][FP_WDIR_WEAPON_FORCLASS]; }
function int Weapon_IsEquipableForPClass(int wid){  
	int forplayerclass = Weapon_GetForClass(wid);

	if(forplayerclass == 0 || StrIEquals(forplayerclass, "0")) return true;
	return StrContainsI(forplayerclass, GetActorClass(990 + PlayerNumber()));
}
function int Weapon_Find(str actor_name) {
	for (int i = 0; i < fp_WeaponStack; i++) {
		if (StrEquals(actor_name, Weapon_GetActor(i))) {
			return i;
		}
	}
	return -1;
}