///////////////////////////////////////////////////
//      SHOTGUN FRENZY PLUS
//   a Shotgun Frenzy fork by Samuzero15tlh

// fl_ItemDir.acs
// item directory

// Here it lays all of the items on the game.
// For the prices, take a look at fl_price.

#library "fl_IDir"

#import "f_intdb.acs"
#import "fl_techs.acs"
#import "fp_lumpread.acs"

#include "zcommon.acs"
#include "acsutils.acs"
#include "samu_tools.acs"

#libdefine FP_ITEM_NUM 255

// Useful for filters.
#libdefine FP_ITEM_T_POWERUP 1
#libdefine FP_ITEM_T_DEPLOY 2
#libdefine FP_ITEM_T_DEFAULT 0
#libdefine FP_ITEM_T_HIDDEN -1

#libdefine ITEMSHOP_ARMORY 0
#libdefine ITEMSHOP_HEALTH_POWERUP 1
#libdefine ITEMSHOP_HEALTH_MISC 2

#libdefine ITEMSHOP_NUM 4

#libdefine ITEM_PROP_TYPE      0
#libdefine ITEM_PROP_ACTOR     1
#libdefine ITEM_PROP_MAXAMOUNT 2
#libdefine ITEM_PROP_PRICE     3
#libdefine ITEM_PROP_NAME      4
#libdefine ITEM_PROP_ICON      5
#libdefine ITEM_PROP_DESC      6
#libdefine ITEM_PROP_IBTN      7
#libdefine ITEM_PROP_SHOWINHUD 8
#libdefine ITEM_PROP_FORCLASS  9

#libdefine ITEMDROP_MAX 4
#libdefine ITEMDROP_PROPS 3
#libdefine ITEMDROP_ITEMS 30
#libdefine ITEMDROP_CLASSES 7

#libdefine ITEMDROP_PROP_ACTOR 0
#libdefine ITEMDROP_PROP_CHANCE 1
#libdefine ITEMDROP_PROP_FORCLASS 2

int ItemDr_stack[ITEMDROP_CLASSES];
int ItemDr_champStack[ITEMDROP_CLASSES];
int ItemDr_rewards[ITEMDROP_CLASSES][ITEMDROP_ITEMS][ITEMDROP_PROPS];
int ItemDr_championRewards[ITEMDROP_CLASSES][ITEMDROP_ITEMS][ITEMDROP_PROPS];

int fp_Items[FP_ITEM_NUM][10];
int fp_itemshop[ITEMSHOP_NUM][100];
int fp_itemshop_last[ITEMSHOP_NUM];
int fp_LastItem = 0;

#libdefine FP_RUNE_MAX 50
#libdefine FP_RUNE_TIERS 4

#libdefine FP_RUNE_PROPERTIES 7

#libdefine RUNE_PROP_NAME 0
#libdefine RUNE_PROP_DESC 1
#libdefine RUNE_PROP_GIVERACTOR 2
#libdefine RUNE_PROP_PRICE 3
#libdefine RUNE_PROP_BTNIMG 4
#libdefine RUNE_PROP_TIER 5
#libdefine RUNE_PROP_POWERACTOR 6

int RuneTop = 0;
int RuneTrack = 0;
int Rune_list[FP_Rune_MAX][FP_RUNE_PROPERTIES]; //[Amount][Props]
int Rune_Saved[32];
int Rune_TierUpPrices[FP_RUNE_TIERS];
int Rune_TierPrices[FP_RUNE_TIERS];

// Item properties
// 0) Item Actor
// 1) Item Name
// 2) Item Max amount

function void SFPlus_DefineItems(void){
	IDir_ReadSFITMDEF();
}

////////////////////
// Item directory //
////////////////////

function void IDir_ReadSFITMDEF(void){
	ACS_NamedExecuteWithResult("LumpRead_LoadFile", "SFITMDEF", "SFPlus_IDir_SFITMDEFReadLine");
}

Script "SFPlus_IDir_SFITMDEFReadLine" (int line) {
	//log(s:"\"", s:line, s:"\"");
	str op = LumpRead_NextArg(line, LUMPR_VALUE_STR);
	int tier, actor, poweractor, langdata, btnimg;
	if (StrIEquals(op, "AddItem")) {
		SFITMDEF_AddItem(line, FP_ITEM_T_DEFAULT);
	} else if (StrIEquals(op, "AddPowerup")) {
		SFITMDEF_AddItem(line, FP_ITEM_T_POWERUP);
	} else if (StrIEquals(op, "AddDeployable")) {
		SFITMDEF_AddItem(line, FP_ITEM_T_DEPLOY);
	} else if (StrIEquals(op, "AddHidden")) {
		SFITMDEF_AddItem(line, FP_ITEM_T_HIDDEN);
	} else if (StrIEquals(op, "ItemDrop")) {
		SFITMDEF_ItemDrop(line, 0);
	} else if (StrIEquals(op, "ItemDropChampion")) {
		SFITMDEF_ItemDrop(line, 1);
	} else if (StrIEquals(op, "ItemDropRune")) {
		SFITMDEF_ItemDrop(line, 2);
	} else if (StrIEquals(op, "ClearAllDrops")) {
		if(!LumpRead_CountArgs(line, 1, 1, "ClearAllDrops")) terminate;
		SFITMDEF_ClearAllDrops();
	} else if (StrIEquals(op, "ClearAllItems")) {
		if(!LumpRead_CountArgs(line, 1, 1, "ClearAllItems")) terminate;
		SFITMDEF_ClearAllItems();
	} else if (StrIEquals(op, "ClearDropsForMonsterClass")) {
		SFITMDEF_ClearDropsForMonClass(line, LumpRead_NextArg(line, LUMPR_VALUE_INT));
	} else if (StrEquals(op, "ClearAllRunes")) {
        RuneDir_ClearAllRunes();
    } else if (StrEquals(op, "AddRune")) {
        tier =         LumpRead_NextArg(line, LUMPR_VALUE_INT);
        actor =        LumpRead_NextArg(line, LUMPR_VALUE_STR);
        poweractor =   LumpRead_NextArg(line, LUMPR_VALUE_STR);
        langdata =     LumpRead_NextArg(line, LUMPR_VALUE_STR);
        btnimg =       LumpRead_NextArg(line, LUMPR_VALUE_STR);

        Rune_Add(tier, actor, poweractor, langdata, btnimg);
    } else if (StrEquals(op, "ReplaceRune")) {
        str actorToReplace = LumpRead_NextArg(line, LUMPR_VALUE_STR);
        tier =           LumpRead_NextArg(line, LUMPR_VALUE_INT);
        actor =          LumpRead_NextArg(line, LUMPR_VALUE_STR);
        poweractor =     LumpRead_NextArg(line, LUMPR_VALUE_STR);
        langdata =       LumpRead_NextArg(line, LUMPR_VALUE_STR);
        btnimg =         LumpRead_NextArg(line, LUMPR_VALUE_STR);

        Rune_Replace(tier, actorToReplace, actor, poweractor, langdata, btnimg);
    } else {
		log(s:"fl_IDir: Invalid command: '", s:op, s:"'", s:", line=", s:line);
	}
}

function void SFITMDEF_AddItem(str line, int type){
	if(!LumpRead_CountArgs (line, 5, 8, "AddItem")) return;
	if(fp_LastItem >= FP_ITEM_NUM) {
		log(s:"(fl_IDir.acs):", s:" Item directory maxed out.");
		return;
	}

	str actor = LumpRead_NextArg (line, LUMPR_VALUE_STR);
	str maxamount = LumpRead_NextArg (line, LUMPR_VALUE_INT);
	str price = "0";
	if(type != FP_ITEM_T_HIDDEN){
		price = LumpRead_NextArg (line, LUMPR_VALUE_CVAR);
	}
	str lang = LumpRead_NextArgDefault (line, LUMPR_VALUE_STR, "UNKNOWN");
	str name = SFITMDEF_WepLanguageValue (lang, "N");
	str desc = SFITMDEF_WepLanguageValue (lang, "D");
	str icon = SFITMDEF_WepLanguageValue (lang, "I");
	int ibtn = SFITMDEF_WepLanguageValue (lang, "B");

	if(type == FP_ITEM_T_POWERUP){
		// Color
		ibtn = LumpRead_NextArgDefault (line, LUMPR_VALUE_INT, 0);
	}
	
	str showinhud = LumpRead_NextArgDefault (line, LUMPR_VALUE_BOOL, true);
	//log(s:"\"", s:actor, s:"\"");

	int in_classic_mode = LumpRead_NextArgDefault (line, LUMPR_VALUE_BOOL, false);

	int forclass = LumpRead_NextArgDefault (line, LUMPR_VALUE_STR, 0);

	if(in_classic_mode){
		if(GameSkill() == 0){
			//log(s:"Actor ", s:actor, s:" is disabled for the classic skill level.");
			return;
		}
	} // This item is excluded from the classic skill mode.
	
	// Item property indices as libdefines
	fp_Items[fp_LastItem][ITEM_PROP_TYPE]      = type;
	fp_Items[fp_LastItem][ITEM_PROP_ACTOR]     = actor;
	fp_Items[fp_LastItem][ITEM_PROP_MAXAMOUNT] = maxamount;
	fp_Items[fp_LastItem][ITEM_PROP_PRICE]     = price;
	fp_Items[fp_LastItem][ITEM_PROP_NAME]      = name;
	fp_Items[fp_LastItem][ITEM_PROP_ICON]      = icon;
	fp_Items[fp_LastItem][ITEM_PROP_DESC]      = desc;
	fp_Items[fp_LastItem][ITEM_PROP_IBTN]      = ibtn;
	fp_Items[fp_LastItem][ITEM_PROP_SHOWINHUD] = showinhud;
	fp_Items[fp_LastItem][ITEM_PROP_FORCLASS]  = forclass;
	//log(s:"[DEBUG fl_IDir] Item #", d:fp_LastItem, s:" type=", d:type, s:" actor=", s:actor, s:" maxamount=", d:maxamount, s:" price=", s:price, s:" name=", s:name, s:" icon=", s:icon, s:" desc=", s:desc, s:" ibtn=", s:ibtn, s:" showinhud=", d:showinhud, s:" in_classic_now=", d:in_classic_mode);
	fp_LastItem++;

	switch(type){
		case FP_ITEM_T_POWERUP:
			Item_AppendToShop(fp_LastItem, ITEMSHOP_HEALTH_POWERUP);
			//log(s:"Health Powerup items: ", d:fp_itemshop_last[ITEMSHOP_HEALTH_POWERUP]);
		break;
		case FP_ITEM_T_DEPLOY:
		case FP_ITEM_T_DEFAULT:
			Item_AppendToShop(fp_LastItem, ITEMSHOP_ARMORY);
		break;
		case FP_ITEM_T_HIDDEN: break;
		default: log(s:"(fl_IDir.acs) Unknown Type number.");
	}
}

function str SFITMDEF_WepLanguageValue (str string, str prop){
	return strparam(l:strparam(s:"ITDATA_", s:prop, s:"_", s:string));
}

// Getters
function int Item_GetType(int it){	return fp_Items[it][ITEM_PROP_TYPE];}
function int Item_GetActor(int it){	return fp_Items[it][ITEM_PROP_ACTOR];}
function int Item_GetMax(int it){	return fp_Items[it][ITEM_PROP_MAXAMOUNT];}
function int Item_GetPrice(int it){
	return fp_Items[it][ITEM_PROP_PRICE];
}
function int Item_GetName(int it){	return fp_Items[it][ITEM_PROP_NAME];}
function int Item_GetIcon(int it){	return fp_Items[it][ITEM_PROP_ICON];}
function int Item_GetDesc(int it){	return fp_Items[it][ITEM_PROP_DESC];}
function int Item_GetIBtnOrColor(int it){return fp_Items[it][ITEM_PROP_IBTN];}
function int Item_GetShowInHud(int it){return fp_Items[it][ITEM_PROP_SHOWINHUD];}
function str Item_GetForClass(int it){return fp_Items[it][ITEM_PROP_FORCLASS];}
function bool Item_IsForClass(int it){
	int forplayerclass = Item_GetForClass(it);

	if(forplayerclass == 0) return true;
	return StrContainsI(forplayerclass, GetActorClass(ActivatorTID()));
}

function void Item_AppendToShop(int it, int shop){
	fp_itemshop[shop][fp_itemshop_last[shop]] = it-1;
	fp_itemshop_last[shop]++;
}

///////////////////////
// Item drop rewards //
///////////////////////

Script "ItemDr_InitRewards" open{
    //Initialize real quick.
    SFITMDEF_ClearAllDrops();
}

function void  SFITMDEF_ClearAllDrops(void) {
	for (int i = 0; i < ITEMDROP_CLASSES; i++) {
		ItemDr_stack[i] = 0;
		ItemDr_champStack[i] = 0;
		for (int j = 0; j < ITEMDROP_ITEMS; j++) {
			for (int k = 0; k < ITEMDROP_PROPS; k++) {
				ItemDr_rewards[i][j][k] = 0;
				ItemDr_championRewards[i][j][k] = 0;
			}
		}
	}
}

function void SFITMDEF_ClearAllItems(void) {
	int i, j = 0;
	fp_LastItem = 0;
	for (int shop = 0; shop < ITEMSHOP_NUM; shop++) {
		fp_itemshop_last[shop] = 0;
		for (i = 0; i < 100; i++) {
			fp_itemshop[shop][i] = 0;
		}
	}
	for (i = 0; i < FP_ITEM_NUM; i++) {
		for (j = 0; j < 10; j++) {
			fp_Items[i][j] = 0;
		}
	}
}

function void SFITMDEF_ClearDropsForMonClass(str line, int class) {
	if(!LumpRead_CountArgs(line, 2, 2, "ClearDropsForMonsterClass")) return;
	ItemDr_stack[class] = 0;
	ItemDr_champStack[class] = 0;
	for (int j = 0; j < ITEMDROP_ITEMS; j++) {
		for (int k = 0; k < ITEMDROP_PROPS; k++) {
			ItemDr_rewards[class][j][k] = 0;
			ItemDr_championRewards[class][j][k] = 0;
		}
	}
}

function void SFITMDEF_ItemDrop(int line, int dropType) {
	// dropType: 0 = ItemDrop, 1 = ItemDropChampion, 2 = ItemDropRune
	str funcName;
	switch(dropType) {
		case 0: funcName = "ItemDrop"; break;
		case 1: funcName = "ItemDropChampion"; break;
		case 2: funcName = "ItemDropRune"; break;
		default: funcName = "UnknownDrop"; break;
	}
	if(!LumpRead_CountArgs(line, 4, 5, funcName)) return;

	int class = LumpRead_NextArg(line, LUMPR_VALUE_INT);

	// Respect item limits
	if (dropType == 0 && ItemDr_stack[class] >= ITEMDROP_ITEMS) {
		log(s:"(ItemDr) ", s:funcName, s:" for class ", d:class, s:" is full. Max items reached.");
		return;
	} else if ((dropType == 1 || dropType == 2) && ItemDr_champStack[class] >= ITEMDROP_ITEMS) {
		log(s:"(ItemDr) ", s:funcName, s:" for class ", d:class, s:" is full. Max champion items reached.");
		return;
	}
	int item, dropChance, tier, playerclasses;

	if(dropType == 0) {
		// ItemDrop
		item = LumpRead_NextArg(line, LUMPR_VALUE_STR);
		dropChance = LumpRead_NextArg(line, LUMPR_VALUE_FIXED);
		playerclasses = LumpRead_NextArgDefault(line, LUMPR_VALUE_STR, 0);
		ItemDr_rewards[class][ItemDr_stack[class]][ITEMDROP_PROP_ACTOR] = item;
		ItemDr_rewards[class][ItemDr_stack[class]][ITEMDROP_PROP_CHANCE] = dropChance;
		ItemDr_rewards[class][ItemDr_stack[class]][ITEMDROP_PROP_FORCLASS] = playerclasses;
		ItemDr_stack[class]++;
	} else if(dropType == 1) {
		// ItemDropChampion
		item = LumpRead_NextArg(line, LUMPR_VALUE_STR);
		dropChance = LumpRead_NextArg(line, LUMPR_VALUE_FIXED);
		playerclasses = LumpRead_NextArgDefault(line, LUMPR_VALUE_STR, 0);
		ItemDr_championRewards[class][ItemDr_champStack[class]][ITEMDROP_PROP_ACTOR] = item;
		ItemDr_championRewards[class][ItemDr_champStack[class]][ITEMDROP_PROP_CHANCE] = dropChance;
		ItemDr_championRewards[class][ItemDr_champStack[class]][ITEMDROP_PROP_FORCLASS] = playerclasses;
		ItemDr_champStack[class]++;
	} else if(dropType == 2) {
		// ItemDropRune
		tier = LumpRead_NextArg(line, LUMPR_VALUE_INT);
		dropChance = LumpRead_NextArg(line, LUMPR_VALUE_FIXED);
		ItemDr_championRewards[class][ItemDr_champStack[class]][ITEMDROP_PROP_ACTOR] = tier*-1;
		ItemDr_championRewards[class][ItemDr_champStack[class]][ITEMDROP_PROP_CHANCE] = dropChance;
		ItemDr_championRewards[class][ItemDr_champStack[class]][ITEMDROP_PROP_FORCLASS] = "";// Everyone deserves a rune :)
		ItemDr_champStack[class]++;
	}
}

function int ItemDr_getItem(int class,int nitem){
	return ItemDr_rewards[class][nitem][ITEMDROP_PROP_ACTOR];
}

function int ItemDr_getDropChance(int class,int nitem){
	return ItemDr_rewards[class][nitem][ITEMDROP_PROP_CHANCE];
}

function str ItemDr_getForPlayerClass(int class, int nitem){
	return ItemDr_rewards[class][nitem][ITEMDROP_PROP_FORCLASS];
}

function bool ItemDr_IsForPlayerClass(int tid, int class, int nitem){
	int forplayerclass = ItemDr_getForPlayerClass(class, nitem);

	if(forplayerclass == 0) return true;
	return StrContainsI(forplayerclass, GetActorClass(tid));
}

function int ItemDr_Dice(int chance){
    bool fixed_d100 = random(0.0, 100.0);
    bool res = (fixed_d100 <= chance);
    /*
    log(s:"(ItemDr) Dice Chance: ", f:chance);
    log(s:"(ItemDr) Dice Random: ", f:fixed_d100);
    log(s:"(ItemDr) Dice Result: ", d:res);
    */
    return res;
}

function int ItemDr_getChance(int class,int nitem){
	return ItemDr_rewards[class][1][nitem];
}

// mmm: drop reward item on monster death

function void ItemDr_Spawn(str item){
    if(item == 0) return;
    //printbold(s:item, s:" was spawned.");
    SpawnForced("ItemFog",
            GetActorX(0) + random(0, 10.0),
            GetActorY(0) + random(0, 10.0),
            GetActorFloorZ(0) + 10.0);
    SpawnForced(item,
            GetActorX(0) + random(0, 10.0),
            GetActorY(0) + random(0, 10.0),
            GetActorFloorZ(0) + 10.0);
}

function void ItemDr_ChampionDrop(int monsterClass){
    bool spawn_fx = false;
    int chance;
    for(int i; i < ItemDr_champStack[monsterClass]; i++){
        chance = ItemDr_championRewards[monsterClass][i][ITEMDROP_PROP_ACTOR];
        int item = ItemDr_championRewards[monsterClass][i][ITEMDROP_PROP_CHANCE];
		int player_killer = GetActorProperty(ActivatorTID(), APROP_TargetTID);
		bool forclass = ItemDr_IsForPlayerClass(player_killer, monsterClass, i);
        if(CheckActorInventory(player_killer, "RuneFortune")){
            chance = chance + 5.0;
        }

        if(ItemDr_Dice(chance) && forclass){
            if(item <= 0){
                str rune = Rune_Pick(item*-1);
                //log(s:"Rune Tier: ", d:(item*-1), s:" Spawning a rune: ", d:rune);
                ItemDr_Spawn(strparam(s:Rune_GetActor(rune), s:"_Drop"));
            }  
            else           ItemDr_Spawn(item);
            break; // Only 1 champion item can be spawned.
        }
    }
    
    spawn_fx = ItemDr_RuneDrops("RuneHealth", "HealthRune_BloodDrip", 2, 5, monsterClass);
    spawn_fx = ItemDr_RuneDrops("RuneAmmunition", "AmmunitionRune_Satchel", 1, 3, monsterClass);
    spawn_fx = ItemDr_RuneDrops("RuneTemperance", "ArmorShard", 3, 6, monsterClass);
    if(spawn_fx)    PlaySound(ActivatorTID(), "misc/spawn");

}

function void ItemDr_MonsterDrop(int monsterClass)
{
    // probability of dropping item
	//[Samu] Alright, im doing this just for the sake of refactoring!
	
  int chance = p_MonsterItem[monsterClass];
  int player_killer = GetActorProperty(ActivatorTID(), APROP_TargetTID);

  if(CheckActorInventory(player_killer, "RuneFortune")){
      chance = chance + 10.0;
  }

  int dropped = 0;
  int spawn_fx = false; 
  if ((ItemDr_Dice(chance))){
    //log(s:"(ItemDr) Success, trying to drop stuff.");
    for (int i = 0; i < ITEMDROP_ITEMS && dropped < ITEMDROP_MAX; i++){
        chance = ItemDr_getChance(monsterClass, i);
		bool forclass = ItemDr_IsForPlayerClass(player_killer, monsterClass, i);
        if(chance != 0.0 && forclass){
            if (ItemDr_Dice(chance)){
                //log(s:"(ItemDr) An item has been dropped!.");
                ItemDr_Spawn(ItemDr_getItem(monsterClass, i));
                spawn_fx = true;
                dropped++;
            }
        }
        
    }
  }
  
    spawn_fx = ItemDr_RuneDrops("RuneHealth", "HealthRune_BloodDrip", 2, 5, monsterClass);
    spawn_fx = ItemDr_RuneDrops("RuneAmmunition", "AmmunitionRune_Satchel", 1, 3, monsterClass);
    spawn_fx = ItemDr_RuneDrops("RuneTemperance", "ArmorShard", 3, 6, monsterClass);
    if(spawn_fx)    PlaySound(ActivatorTID(), "misc/spawn");
}


function int ItemDr_RuneDrops(str rune, str drop, int min_, int max_, int monsterClass) {

    if(GameSkill() == 0) return 0;

    bool spawn_fx = 0;
    int chance = (5 + monsterClass*2) * 1.0;
	int playerKiller = GetActorProperty(ActivatorTID(), APROP_TargetTID);
    if(CheckActorInventory(playerKiller, "RuneFortune")){
      chance = chance + 10.0;
    }
    if(CheckActorInventory(playerKiller, rune)){
        if(ItemDr_Dice(chance)){
            for(int id = 0; id < random(min_,max_); id++){
                ItemDr_Spawn(drop);
            }
            spawn_fx = true;
        }
    }
    return spawn_fx;
}

//////////////////////////////////////////////
// Rune Directory  stuff cuz i'm fking lazy //
//////////////////////////////////////////////

function void SFPlus_DefineRunes(void){
    Rune_TierUpPrices[1] = GetCvar("pr_rt_u2");
    Rune_TierUpPrices[2] = GetCvar("pr_rt_u3");
    Rune_TierUpPrices[3] = GetCvar("pr_rt_u4");
    Rune_TierPrices[0] = GetCvar("pr_rt_1");
    Rune_TierPrices[1] = GetCvar("pr_rt_2");
    Rune_TierPrices[2] = GetCvar("pr_rt_3");
    Rune_TierPrices[3] = GetCvar("pr_rt_4");

    RuneTop = 0;
}

function void Rune_Replace(int tier, str actorToReplace, str actor, str poweractor, str langdata, str btnimg) {
    int found = 0;
    for (int i = 0; i < RuneTop; i++) {
        if (StrEquals(Rune_List[i][RUNE_PROP_GIVERACTOR], actorToReplace)) {
            Rune_List[i][RUNE_PROP_NAME] = StrParam(l:strparam(s:"FP_RN_", s:langdata));
            Rune_List[i][RUNE_PROP_DESC] = StrParam(l:strparam(s:"FP_RD_", s:langdata));
            Rune_List[i][RUNE_PROP_GIVERACTOR] = actor;
            Rune_List[i][RUNE_PROP_PRICE] = GetCvar(strparam(s:"pr_rt_", d:(tier == -1 ? Rune_List[i][5] : tier)));
            Rune_List[i][RUNE_PROP_BTNIMG] = btnimg;
            Rune_List[i][RUNE_PROP_TIER] = (tier == -1 ? Rune_List[i][5] : tier);
            Rune_List[i][RUNE_PROP_POWERACTOR] = poweractor;
            found = 1;
            break;
        }
    }
    if (!found) {
        log(s:"(fl_IDir): ReplaceRune failed, actor not found: ", s:actorToReplace);
    }
}

function void RuneDir_ClearAllRunes(void) {
    RuneTop = 0;
    for (int i = 0; i < FP_Rune_MAX; i++) {
        for (int j = 0; j < 7; j++) {
            Rune_List[i][j] = 0;
        }
    }
}

function void Rune_Add (int tier, str actor, str poweractor, str langdata, str btnimg){
	int upg = RuneTop;
	
	if(RuneTop >= FP_Rune_MAX)
	{ 
		log(s:"(fl_IDir): Too much runes!");
		return;
	}
	// Look up language.txt
	Rune_List[upg][RUNE_PROP_NAME] = StrParam(l:strparam(s:"FP_RN_", s:langdata));
	Rune_List[upg][RUNE_PROP_DESC] = StrParam(l:strparam(s:"FP_RD_", s:langdata));
	Rune_List[upg][RUNE_PROP_GIVERACTOR] = actor;
	// Lookup fl_price.acs
	Rune_List[upg][RUNE_PROP_PRICE] = GetCvar(strparam(s:"pr_rt_", d:tier)); 
    //log(s:"Rune price: ", d:GetCvar(strparam(s:"pr_rt_", d:tier)));
	Rune_List[upg][RUNE_PROP_BTNIMG] = btnimg;
    Rune_List[upg][RUNE_PROP_TIER] = tier;
    Rune_List[upg][RUNE_PROP_POWERACTOR] = poweractor;
	RuneTop++;
}

function str Rune_getName(int up){	return Rune_List[up][RUNE_PROP_NAME];}
function str Rune_getDesc(int up){	return Rune_List[up][RUNE_PROP_DESC];}
function str Rune_getActor(int up){	return Rune_List[up][RUNE_PROP_GIVERACTOR];}
function str Rune_getIcon(int up){	return Rune_List[up][RUNE_PROP_BTNIMG];}
function str Rune_getTier(int up){	return Rune_List[up][RUNE_PROP_TIER];}
function int Rune_getPrice(int up){	return Rune_List[up][RUNE_PROP_PRICE];}
function str Rune_getPowerActor(int up){ return Rune_List[up][RUNE_PROP_POWERACTOR];}

function int Rune_getCurrent(void){ 
    int res = -1;
    for(int i; i < RuneTop; i++){
        if(CheckInventory(Rune_getPowerActor(i))){
            res = i;
            break;
        }
    }
    return res;
}

function int Rune_GetScore(void){
	int i;
	int score = RuneTrack;
	int players = 0;
	
	for(i = 0; i < 64; i++){
		if(PlayerInGame(i)) players++;
		else break;
	}

	if(!players) return 0;
	return (score) / players;
}

function void Rune_SaveAndUnequip(void){ 
    int play = PlayerNumber();
    Rune_Saved[play] = Rune_getCurrent();
    TakeInventory(Rune_getPowerActor(Rune_Saved[play]), 1);
}

function void Rune_LoadAndEquip(void){ 
    int play = PlayerNumber();
    GiveInventory(Rune_getActor(Rune_Saved[play]), 1);
    Rune_Saved[play] = -1;
}

function int Rune_getTierUnlockPrice(int tier){ 
    return Rune_TierUpPrices[tier-1];
}

function int Rune_getTierPrice(int tier){ 
    return Rune_TierPrices[tier];
}

Script "SFPlus_RandomRune" (int arg) {
    int pick = Rune_Pick(arg);
    //print(d:pick,s:") ", s:Rune_getName(pick));
}

function int Rune_Pick(int tier){
    int result;
    if(tier == 0) 
    {
        result = random(0, RuneTop-1);
    } 
    else {
        int picks[5];
        int stackpicks = 0;
        for(int i; i < RuneTop; i++){
            if(tier == Rune_getTier(i)){
                picks[stackpicks] = i;
                stackpicks++;
            }
        }
        result = picks[random(0, stackpicks-1)];
        
    }
    return result;
}