#library "fp_runes"
#include "zcommon.acs"
#import "f_tip.acs"

script "Rune_Events" (int type, int arg1, int arg2) Event {
    
    switch(type){
        case GAMEEVENT_ACTOR_DAMAGED:
            int hpold = getActorProperty(0, APROP_HEALTH);
            int hpnow = hpold - arg1;
            if(playernumber() >= 0){
                SetResultValue(ACS_NamedExecuteWithResult("Runes_OnPlayerDamage", arg1, hpnow <= 0));
            }
        break;
        case GAMEEVENT_ACTOR_ARMORDAMAGED:
        //if(GetArmorInfo(ARMORINFO_CLASSNAME))log(s:GetArmorInfo(ARMORINFO_CLASSNAME));
            // Temperance will now add extra percentages to the saving amount
            int dmg = arg1;
            int percent;
            //log(s:arg2);
            if(!stricmp(arg2, "Suicide")) terminate;
            if(stricmp(GetArmorInfo(ARMORINFO_CLASSNAME), "TitaniumArmor") == 0){
                percent = 0.45 + 0.15 * checkinventory("RuneTemperance");
                dmg = (arg1 * (1.0 - percent)) >> 16;

                ArmorHitSFX(dmg);
                SetResultValue(dmg);
            }
            
             
            if(stricmp(GetArmorInfo(ARMORINFO_CLASSNAME), "SteelPlatingArmor") == 0){
                percent = 0.175 + 0.16 * checkinventory("RuneTemperance");
                dmg = (arg1 * (1.0 - percent)) >> 16;

                ArmorHitSFX(dmg);
                SetResultValue(dmg);
            }

            if(stricmp(GetArmorInfo(ARMORINFO_CLASSNAME), "MegasphereArmor") == 0 ||
                stricmp(GetArmorInfo(ARMORINFO_CLASSNAME), "SuperMegasphere_Armor") == 0){
                percent = 0.30 + 0.20 * checkinventory("RuneTemperance");
                dmg = (arg1 * (1.0 - percent)) >> 16;

                
                ArmorHitSFX(dmg);
                SetResultValue(dmg);
            }
        break;
    }    
}

function void ArmorHitSFX(int dmg){
    if(CheckInventory("BasicArmor") <= dmg){
        LocalAmbientSound("runes/temperance/break", 127);
        GiveInventory("TemperanceRune_GuardBreak", 1);
    }else {
        GiveInventory("TemperanceRune_GuardHit", 1);
        LocalAmbientSound("runes/temperance/hit", 127);
    }
}

script "Runes_ConstantEffects" (void) {
    int last_health = GetActorProperty(ActivatorTID(), APROP_HEALTH);
    int tics = 0;
    while(GetActorProperty(ActivatorTID(), APROP_HEALTH) > 0) {

        if(checkinventory("RuneHealth")){
            last_health = RuneEffect_ExtraHealth(last_health, 0.5); 
        }

        if(CheckInventory("RuneAmmunition")) {
            if(tics == 1 && random(0, 100) < 20){
                GiveInventory("AmmunitionRune_Activate", 1);
                //log(s:"Infinite ammo.");
            }
        }

        if(checkinventory("RuneSoul")){
            GiveInventory("SoulRune_Activate", 1);
        }else{
            GiveInventory("SoulRune_Reset", 1);
        }

        tics = (tics % 35) + 1;
        delay(1);
    }
    GiveInventory("SoulRune_Reset", 1);
}

function int RuneEffect_ExtraHealth(int last_health, int health_mult)
{
	int health = GetActorProperty(0, APROP_Health);
	int maxHealth = GetActorProperty(0, APROP_SpawnHealth);
	if(maxHealth == 0){ maxHealth = 100; /* default max */ }
	int left = maxHealth - health;
	if(left > 0 && last_health != health){
		int heal = health - last_health;
		if(heal >= left) heal = left; // Only gains, not loss
		// The difference between the health on the last tick and your current health is recived.
		GiveInventory("Health", (heal * health_mult) >> 16);
		//Print(s:"ExtraHealth: ", d:((heal * health_mult) >> 16));
	}
	last_health = GetActorProperty(0, APROP_Health);
	return last_health;
}

script "SFPlus_OnTeleport" (void) {
	// What happens to the teleported things?
	SetActivatorToTarget(0);
	delay(5);
	if(CheckActorClass(ActivatorTID(), "FrenzyPlayer")){
		// If a player was teleported, check if he got the spawn protection upgrade.
		if(CheckActorInventory(ActivatorTID(), "PlayUp_SpawnShield")){
			TakeActorInventory(ActivatorTID(), "PlayUp_SpawnShield_Power", 1);
			delay(1);
			giveActorinventory(ActivatorTID(),"PlayUp_SpawnShield_Activate", 1);
		}
	}
}

script "Runes_OnPlayerDamage" (int dmg, int fatal){
    int TotalDmg = dmg;
    if(fatal){
        if(checkinventory("RuneResurrection")){
            GiveInventory("ResurrectionRune_Activate", 1);
            TotalDmg = 0; // Deny effective damage.
        }
        
        if(CheckInventory("PlayUp_Prometeo") && !CheckInventory("PlayUp_Prometeo_Used")){
            // Activate Prometeo Protocol effect.
            setactorproperty(0, APROP_SpawnHealth, 50);
            setactorproperty(0, APROP_Health, 51);
            giveinventory("PlayUp_Prometeo_Activate", 1);
            TotalDmg = 1; // Just to call the pain state.
        }
    }
    else{
        if(checkinventory("RuneDefense")){
            GiveInventory("DefenseRune_Activate", 1);
        }

        if(checkinventory("RuneBlast")){
            GiveInventory("BlastRune_Activate", 1);
        }
    }
    SetResultValue(TotalDmg);
}


script "Runes_OnMonsterKill" (int ischamp){
    if(checkinventory("RuneRampage")){
        GiveInventory("RampageRune_Activate", 1);
    }

    if(checkinventory("RuneSoul")){
        if(ischamp){
            GiveInventory("SoulRune_ChampCounter", 1);
        } 
        else        GiveInventory("SoulRune_Counter", 1);
        
    }
}

script "Runes_PickMessage" (int type){
    f_SmallTip ("Hold Use to link this rune!", CR_CYAN, 0);
}


script "SFPlus_Dash" (void){
    int DASH_SPD = 40; // Speed defined by monster.
    int dashAngle = GetActorAngle(0);
    int speed_cap = (DASH_SPD * 10.0) >> 16;
    int factor_slide = 0.12;
    str str_speed = "";
    int a = "";
    int slidertime = 35;
    int i;
    int min_speed;
    for(i = 0; i < slidertime; i++)
    {
        if(GetActorZ(0) == GetActorFloorZ(0))
        {
            SetActorPosition(0, GetActorX(0), GetActorY(0), GetActorZ(0)+1.0, FALSE);
            SetActorVelocity(0, cos(dashAngle) * DASH_SPD, sin(dashAngle) * DASH_SPD, 0.0, FALSE, FALSE);
            //if(DASH_SPD < speed_cap) 
            if((DASH_SPD * factor_slide) < 1.0) min_speed = 1;
            else min_speed = (DASH_SPD * factor_slide >> 16);
            DASH_SPD = DASH_SPD - min_speed;// slow it down
            if(DASH_SPD < 0)SetActorVelocity(0, 0, 0, 0.0, FALSE, FALSE);
            a = strparam(s:" dash_speed: ", d:DASH_SPD, s:" \n");
            str_speed = strparam(s:str_speed, s:a);
            print(s:str_speed);
        }
        delay(4);
    }
}